## 4.4 object 키워드 :  클래스 선언과 인스턴스 생성
> object 키워드를 사용하는 모든 경우 클래스를 정의하면서 동시에 객체를 생성한다는 공통점이 있다.

* 객체 선언은 싱글톤을 정의하는 방법 중 하나.
* 동반 객체는 인스턴스 메소드는 아니지만 어떤 클래스와 관련있는 메소드와 팩토리 메소드를 담을 때 쓰인다.
* 객체 식은 자바의 익명 내부 클래스 대신 쓰인다.

### 4.4.1 객체 선언: 싱클톤 쉽게 만들기
객체 선언 : 클래스 선언 + 단일 인스턴스 선언

* 객체 접근 시점에 객체가 생성된다.
* 주/부 생성자를 사용할 수 없다.
   (객체 선언과 동시에 생성자 호출 없이 바로 만들어진다.)
* 상속과 인터페이스 구현할 수 있다.
* 프로퍼티, 메소드, 초기화 블록이 들어갈 수 있다.
* 클래스 안에서 객체 선언을 사용하더라도 객체 선언의 인스턴스는 단 하나만 생성된다.
```java
	obejct DataProviderManager {
		fun registerDataProvider(provider: DataProvider) {...}

		val allDataProviders: Collection<DataProvider>
		get() = ...
	}
>> DataProviderManager.registerDataProvider(..)
	// 객체를 사용할 때는 이름 그대로 사용하면 된다.
```
* 싱클톤 객체를 함수의 인자로 넘겨줄 수 있다.
*  클래스 안에서 객체를 선언할 수 있다. (중첩 객체)
```java
	data class Person(val name: String) {
		object NameComparator : Comparator<Person> {
			override fun compare(p1: Person, p2: Person): Int =
				p1.name.compareTo(p2.name)
		}
	} 
```

### 4.4.2 동반 객체 : 팩토리 메소드와 정적 멤버가 들어갈 장소
> 코틀린은 static 키워드를 지원하지 않는 대신, 최상위 함수와 객체 선언을 활용한다.

**최상위 함수를 사용할 때, 주의할 점**
==최상위 함수는 클래스의 private 멤버에 접근할 수 없다.==
클래스의 private 멤버에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의한다.
ex ) 팩토리 메소드

클래스 안에 정의된 객체에 _companion_ 키워드를 붙이면 그 클래스의 동반 객체가 된다.
> 동반 객체의 프로퍼티나 메소드에 접근하려면 해당 클래스 이름을 사용하면 된다.
> 객체의 이름은 따로 지정할 필요가 없다.
> 자바의 정적 메소드 호출, 정적 필드 사용 구문과 같다.

```java
	class A {
		companion object {
			fun bar() {
				println("Companion object called")
			}
		}
	}

	A.bar()
	>> Companion object called
```
* 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다.
	(private 생성자를 호출할 수 있다.)
```java
	class User {
		val nickname: String
		constructor(email: String) {
			nickname = email.substringBefore('@')
		} // 부 생성자

		constructor(facebookAccountId: Int) {
			nickname = getFaceboockName(facebookAccountId)
		} // 부 생성자
	}
```

위의 코드를 팩토리 메소드로 구현해보자.

```java
	class User private constructor(val nickname: String) { 
	// 생성자의 가시성이 private이다. 외부에서 User클래스의 인스턴스 생성 불가능
		companion object { 
			// 동반 객체를 사용해서 User 인스턴스 생성해야 함.
			fun newSubscribingUser(email: String) = 
				User(email.substringBefore('@'))
			fun newFacebookUser(accountId: Int) = 
				User(getFacebookName(accountId))
		}
	}

	>>> val subscribingUser = User.newSubscribingUser("bob@gamil.com")
	>>> val facebookUser = User.newFacebookUser(4)
	>>> println(subscribingUser.nickname)
	bob
```
* 팩토리 메소드가 선언된 클래스의 하위 클래스 객체를 반환할 수 있다.
* 생성할 필요가 없는 객체를 생성하지 않을 수도 있다.
	이미 존재하는 인스턴스에 해당하는 정보를 받을 경우, 기존 인스턴스를 반환할 수 있다.

**클래스를 확장해야 하는 경우 동반 객체 멤버를 하위 클래스에서 오버라이드할 수 없으므로 여러 생성자를 사용하는 편이 더 낫다.**
